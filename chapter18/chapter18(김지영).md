## Chapter 18 함수형 관점으로 생각히기

### 18.1 시스템 구현과 유지보수
함수형 프로그래밍이 제공하는 부작용 없음(no side effect)과 불변성(immutability)이라는 개념은 시스템의 유지보수에 큰 도움을 준다.  

**공유된 가변 데이터**  
변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.  
예를 들어 여러 클래스에서 공유하는 가변리스트가 있다면 어느 클래스가 소유자인지 구분하기 어려워 테이터 갱신 사슬을 추적하기 어려워진다.  

어떤 자료구조도 바뀌지 않는 시스템이 있다면 유지보수하기 매우 쉬워질 것이다.  
이처럼 클래스 또는 객체의 상태를 바꾸지 않으며 return 문을 통해서만   
자신의 결과를 반환하는 메서드를 순수(pure) 메서드 또는 부작용 없는(no side effect) 메서드라고 부른다.  
여기서 부작용은 함수 내에 포함되지 못한 기능을 의미한다.  
다음은 부작용의 예이다.
- 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행


불변 객체를 이용해 부작용을 없애는 방법도 있다.  
불변 객체는 인스턴스화한 다음에는 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.  
부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하지 않으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다.

**선언형 프로그래밍**  
1) '어떻게(how)' 구현할 것인지 집중하는 프로그래밍 형식은 고전적 객체지향 프로그래밍에서 이용하는 방식이다.  
이를 명령형 프로그래밍이라고 부르기도 한다.
```java
Transaction mostExpensive = transactions.get(0);
if (mostExpensive == null)
  throw new IllegalArgumentException("Empty list of transactions");
  
for(Transaction t: transactions.subList(1, transactions.size())) {
  if (t.getValue() > mostExpensive.getValue()) {
    mostExpensive = t;
  }
}
```
2) '무엇을'에 집중하는 방식(=선언형 프로그래밍)도 있다.  
질의문 구현 방법은 라이브러리가 결정하며 이와 같은 구현방식을 내부 반복이라고 한다.  
 질의문 자체를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.  
```java
Optional<Transaction> mostExpensive =
    transactions.stream().max(comparing(Transaction::getValue));
```

**왜 함수형 프로그래밍인가?**  
함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용 없는 계산을 지향한다.  
선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.  

### 18.2 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍은 말 그대로 함수를 이용하는 프로그래밍이다.  
여기서 함수형 프로그래밍에서 말하는 함수는 수학적인 함수와 같다.   
함수는 0개 이상의 인수를 가지며 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다.  
.함수는 시스템의 다른 부분에 영향을 미치지 않아야 하며 이런 특징을 참조 투명성이라 한다.   
반면, 공유된 가변 데이터를 수정하여 시스템의 다른 부분에 영향을 미친다면 이는 함수형 메서드가 아니다.  
함수 그리고 if-then-else 등의 수학적 표현만 사용하는 방식을 순수 함수형 프로그래밍이라고 허며  
시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용하는 방식으로 함수형 프로그래밍이라고 한다.  

**함수형 자바**  
자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.  
자바에서는 순수 함수형이 아닌 함수형 프로그래밍을 구현한다.  
함수나 메서드는 지역변수만을 변경해야 하며, 참조하는 객체가 있다면 불변객체여야 한다.  
메서드 내에서 생성한 객체의 필드는 갱신할 수 있지만, 외부에 노출되어서는 안된다.  
또한 함수나 메서드가 어떤 예외도 일으키지 않아야 한다. 예외가 발생하면 return으로 결과를 반환할 수 없게 되기 때문이다.  

예외를 사용하지 않고 나눗셈 같은 함수를 표현하려면?  
double sqrt(double) 대신 Optional<Double> sqrt(double)을 이용해 예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아닌지 알 수 있다.  

또한  
함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.   
자료구조를 복사해서 사용한다거나, 발생할 수 있는 예외를 적절하게 내부적으로 처리하여 자료구조 변경을 호출자가 알 수 없도록 감춘다.

**참조 투명성**  
‘부작용을 감춰야 한다’라는 제약은 참조 투명성이라는 개념으로 귀결된다.    
즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 할 수 있다.  
다시 말해 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.  
따라서, Random.nextInt는 함수형이 될 수 없다.   

참조 투명성과 관련된 작은 문제
List를 반환하는 메서드를 두 번 호출한다고 가정하자.
결과 리스트가 가변 객체라면 반환된 두 리스트는 같은 객체라 할 수 없다.  
따라서 이 메서드는 참조적으로 투명한 메서드가 아니다.
하지만 결과 리스트를 불변 값으로 사용할 것이라면 두 리스트는 같은 객체라 볼 수 있으므로  
참조적으로 투명한 것으로 간주할 수 있다.  

**객체지향 프로그래밍과 함수형 프로그래밍**  
객체지향 프로그래밍과 함수형 프로그래밍은 반대되는 속성을 가진다.  
객체지향 프로그래밍은 모든 것을 객체로 간주하며, 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하여 관련 객체를 갱신하는 방식으로 동작한다.  
반대로, 함수형 프로그래밍은 참조적 투명성을 중요시한다. 즉, 변화를 허용하지 않는 방식이다.  
실제로 자바 프로그래머는 이 두 가지 형식을 혼합하여 사용한다.   

### 18.3 재귀와 반복
순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 포함하지 않는다.    
루프 내부에서 프로그램이 공유된 가변 데이터의 상태를 변화시킬 수 있기 때문이다.  
모든 반복은 재귀로도 구현할 수 있다. 하지만 반복 코드보다 재귀 코드가 더 비싸다.  
재귀 함수 호출 할때 마다 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만즐어지기 때문이다.(=메모리 사용량 증가)  
큰 입력값을 사용하면 StackOverflowError가 발생한다.

함수형 언어에서는 재귀호출 시 꼬리재귀에 대하여 꼬리 호출 최적화(tail-call optimization, CTO)라는 해결책을 제공한다.    
중간 결과를 각각의 스택 프레임으로 저장해야 하는 일반 재귀와 달리      
꼬리 재귀에서는 컴파일러가 하나의 스택프레임을 재활용할 가능성이 생긴다.    
하지만 자바에서는 이와 같은 최적화를 제공하지 않는다.    
(스칼라, 그루비 같은 최신 JVM 언어는 제공함)  

결론적으로 자바 8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있고, 재귀로 바꿈으로써 더 간결하고 부작용 없는 알고리즘을 만들 수 있다.  
실제로 재귀를 이용하면 좀더 쉽게, 쓰고, 이해할 수 있는 예제를 만들 수 있다.
또한 약간의 실행시간 차이보다 프로그래머의 효율성이 더 중요할 때도 많다.
